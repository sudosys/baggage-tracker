//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class BaggageTrackerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticationRequest | undefined): Observable<AuthenticationResponse> {
        let url_ = this.baseUrl + "/api/Authentication/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticationResponse>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param flightNumber (optional) 
     * @return Success
     */
    baggageQrCode(flightNumber: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/BaggageTracking/baggage-qr-code?";
        if (flightNumber === null)
            throw new Error("The parameter 'flightNumber' cannot be null.");
        else if (flightNumber !== undefined)
            url_ += "flightNumber=" + encodeURIComponent("" + flightNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBaggageQrCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBaggageQrCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBaggageQrCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    baggageStatusAll(userId: number | undefined): Observable<BaggageDto[]> {
        let url_ = this.baseUrl + "/api/BaggageTracking/baggage-status?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBaggageStatusAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBaggageStatusAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BaggageDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BaggageDto[]>;
        }));
    }

    protected processBaggageStatusAll(response: HttpResponseBase): Observable<BaggageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BaggageDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param baggageId (optional) 
     * @param newStatus (optional) 
     * @return Success
     */
    baggageStatus(baggageId: string | undefined, newStatus: BaggageStatus | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/BaggageTracking/baggage-status?";
        if (baggageId === null)
            throw new Error("The parameter 'baggageId' cannot be null.");
        else if (baggageId !== undefined)
            url_ += "baggageId=" + encodeURIComponent("" + baggageId) + "&";
        if (newStatus === null)
            throw new Error("The parameter 'newStatus' cannot be null.");
        else if (newStatus !== undefined)
            url_ += "newStatus=" + encodeURIComponent("" + newStatus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBaggageStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBaggageStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBaggageStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param qrCodeData (optional) 
     * @return Success
     */
    qrCodeScan(qrCodeData: string | undefined): Observable<QrCodeScanResponse> {
        let url_ = this.baseUrl + "/api/BaggageTracking/qr-code-scan?";
        if (qrCodeData === null)
            throw new Error("The parameter 'qrCodeData' cannot be null.");
        else if (qrCodeData !== undefined)
            url_ += "qrCodeData=" + encodeURIComponent("" + qrCodeData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQrCodeScan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQrCodeScan(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QrCodeScanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QrCodeScanResponse>;
        }));
    }

    protected processQrCodeScan(response: HttpResponseBase): Observable<QrCodeScanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QrCodeScanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: UserRegistration | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/User/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    userDELETE(userId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/User?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserDELETE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserDELETE(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUserDELETE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param passengersOnly (optional) 
     * @return Success
     */
    userAll(passengersOnly: boolean | undefined): Observable<User[]> {
        let url_ = this.baseUrl + "/api/User?";
        if (passengersOnly === null)
            throw new Error("The parameter 'passengersOnly' cannot be null.");
        else if (passengersOnly !== undefined)
            url_ += "passengersOnly=" + encodeURIComponent("" + passengersOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User[]>;
        }));
    }

    protected processUserAll(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    userGET(userId: number): Observable<User> {
        let url_ = this.baseUrl + "/api/User/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserGET(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserGET(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processUserGET(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    userAll2(flightNumber: string): Observable<User[]> {
        let url_ = this.baseUrl + "/api/User/{flightNumber}";
        if (flightNumber === undefined || flightNumber === null)
            throw new Error("The parameter 'flightNumber' must be defined.");
        url_ = url_.replace("{flightNumber}", encodeURIComponent("" + flightNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserAll2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserAll2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User[]>;
        }));
    }

    protected processUserAll2(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AuthenticationRequest implements IAuthenticationRequest {
    username?: string | undefined;
    password?: string | undefined;

    constructor(data?: IAuthenticationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface IAuthenticationRequest {
    username?: string | undefined;
    password?: string | undefined;
}

export class AuthenticationResponse implements IAuthenticationResponse {
    status?: AuthenticationStatus;
    user?: UserSlimDto;
    token?: string | undefined;

    constructor(data?: IAuthenticationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.user = _data["user"] ? UserSlimDto.fromJS(_data["user"]) : <any>undefined;
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): AuthenticationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["token"] = this.token;
        return data;
    }
}

export interface IAuthenticationResponse {
    status?: AuthenticationStatus;
    user?: UserSlimDto;
    token?: string | undefined;
}

export enum AuthenticationStatus {
    Success = "Success",
    Failure = "Failure",
}

export class Baggage implements IBaggage {
    baggageId?: string;
    baggageName?: string | undefined;
    baggageStatus?: BaggageStatus;

    constructor(data?: IBaggage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baggageId = _data["baggageId"];
            this.baggageName = _data["baggageName"];
            this.baggageStatus = _data["baggageStatus"];
        }
    }

    static fromJS(data: any): Baggage {
        data = typeof data === 'object' ? data : {};
        let result = new Baggage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baggageId"] = this.baggageId;
        data["baggageName"] = this.baggageName;
        data["baggageStatus"] = this.baggageStatus;
        return data;
    }
}

export interface IBaggage {
    baggageId?: string;
    baggageName?: string | undefined;
    baggageStatus?: BaggageStatus;
}

export class BaggageDto implements IBaggageDto {
    baggageId?: string;
    baggageName?: string | undefined;
    baggageStatus?: BaggageStatus;

    constructor(data?: IBaggageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baggageId = _data["baggageId"];
            this.baggageName = _data["baggageName"];
            this.baggageStatus = _data["baggageStatus"];
        }
    }

    static fromJS(data: any): BaggageDto {
        data = typeof data === 'object' ? data : {};
        let result = new BaggageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baggageId"] = this.baggageId;
        data["baggageName"] = this.baggageName;
        data["baggageStatus"] = this.baggageStatus;
        return data;
    }
}

export interface IBaggageDto {
    baggageId?: string;
    baggageName?: string | undefined;
    baggageStatus?: BaggageStatus;
}

export enum BaggageStatus {
    Undefined = "Undefined",
    WaitingForLoad = "WaitingForLoad",
    InThePlane = "InThePlane",
    UnloadedFromThePlane = "UnloadedFromThePlane",
    InTheLostOffice = "InTheLostOffice",
    ReceivedByThePassenger = "ReceivedByThePassenger",
}

export class Flight implements IFlight {
    id?: number;
    flightNumber?: string | undefined;

    constructor(data?: IFlight) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.flightNumber = _data["flightNumber"];
        }
    }

    static fromJS(data: any): Flight {
        data = typeof data === 'object' ? data : {};
        let result = new Flight();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["flightNumber"] = this.flightNumber;
        return data;
    }
}

export interface IFlight {
    id?: number;
    flightNumber?: string | undefined;
}

export class QrCodeScanResponse implements IQrCodeScanResponse {
    baggage?: BaggageDto;
    scanResult?: QrCodeScanResult;

    constructor(data?: IQrCodeScanResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baggage = _data["baggage"] ? BaggageDto.fromJS(_data["baggage"]) : <any>undefined;
            this.scanResult = _data["scanResult"];
        }
    }

    static fromJS(data: any): QrCodeScanResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QrCodeScanResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baggage"] = this.baggage ? this.baggage.toJSON() : <any>undefined;
        data["scanResult"] = this.scanResult;
        return data;
    }
}

export interface IQrCodeScanResponse {
    baggage?: BaggageDto;
    scanResult?: QrCodeScanResult;
}

export enum QrCodeScanResult {
    Success = "Success",
    CodeInvalid = "CodeInvalid",
    NotOwnedByPassenger = "NotOwnedByPassenger",
    UnknownError = "UnknownError",
}

export class User implements IUser {
    id?: number;
    username?: string | undefined;
    fullName?: string | undefined;
    role?: UserRole;
    activeFlight?: Flight;
    baggages?: Baggage[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.fullName = _data["fullName"];
            this.role = _data["role"];
            this.activeFlight = _data["activeFlight"] ? Flight.fromJS(_data["activeFlight"]) : <any>undefined;
            if (Array.isArray(_data["baggages"])) {
                this.baggages = [] as any;
                for (let item of _data["baggages"])
                    this.baggages!.push(Baggage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["fullName"] = this.fullName;
        data["role"] = this.role;
        data["activeFlight"] = this.activeFlight ? this.activeFlight.toJSON() : <any>undefined;
        if (Array.isArray(this.baggages)) {
            data["baggages"] = [];
            for (let item of this.baggages)
                data["baggages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    id?: number;
    username?: string | undefined;
    fullName?: string | undefined;
    role?: UserRole;
    activeFlight?: Flight;
    baggages?: Baggage[] | undefined;
}

export class UserRegistration implements IUserRegistration {
    username?: string | undefined;
    fullName?: string | undefined;
    password?: string | undefined;
    flightNumber?: string | undefined;
    baggages?: string[] | undefined;

    constructor(data?: IUserRegistration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.fullName = _data["fullName"];
            this.password = _data["password"];
            this.flightNumber = _data["flightNumber"];
            if (Array.isArray(_data["baggages"])) {
                this.baggages = [] as any;
                for (let item of _data["baggages"])
                    this.baggages!.push(item);
            }
        }
    }

    static fromJS(data: any): UserRegistration {
        data = typeof data === 'object' ? data : {};
        let result = new UserRegistration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["flightNumber"] = this.flightNumber;
        if (Array.isArray(this.baggages)) {
            data["baggages"] = [];
            for (let item of this.baggages)
                data["baggages"].push(item);
        }
        return data;
    }
}

export interface IUserRegistration {
    username?: string | undefined;
    fullName?: string | undefined;
    password?: string | undefined;
    flightNumber?: string | undefined;
    baggages?: string[] | undefined;
}

export enum UserRole {
    Passenger = "Passenger",
    Personnel = "Personnel",
}

export class UserSlimDto implements IUserSlimDto {
    id?: number;
    username?: string | undefined;
    fullName?: string | undefined;
    role?: UserRole;

    constructor(data?: IUserSlimDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.fullName = _data["fullName"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): UserSlimDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSlimDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["fullName"] = this.fullName;
        data["role"] = this.role;
        return data;
    }
}

export interface IUserSlimDto {
    id?: number;
    username?: string | undefined;
    fullName?: string | undefined;
    role?: UserRole;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}